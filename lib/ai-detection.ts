import { callOpenAI } from "./openai-client"

export interface AIDetectionResult {
  ai_probability: number
  human_probability: number
  confidence: number
  analysis: string
  timestamp: string
  status: 'success' | 'error'
}

export async function detectAIWithOpenAI(text: string): Promise<AIDetectionResult> {
  try {
    const systemPrompt = `You are an expert AI content detector. Analyze the given text and determine the probability that it was generated by AI.

Your task is to:
1. Analyze the writing style, vocabulary, sentence structure, and patterns
2. Look for signs of AI generation (repetitive patterns, overly formal language, lack of personal voice, etc.)
3. Provide a probability score from 0-100 where 0 = definitely human, 100 = definitely AI
4. Give a brief analysis explaining your reasoning

Respond in this exact JSON format:
{
  "ai_probability": number (0-100),
  "confidence": number (0-100),
  "analysis": "string explaining your reasoning"
}`

    const userPrompt = `Please analyze this text for AI-generated content:

"${text}"

Provide your analysis in the specified JSON format.`

    const messages = [
      { role: "system", content: systemPrompt },
      { role: "user", content: userPrompt }
    ]

    const response = await callOpenAI("gpt-4", messages, {
      temperature: 0.3,
      max_tokens: 500
    })

    if (response.error) {
      throw new Error(`OpenAI API error: ${response.error}`)
    }

    const content = response.choices[0].message.content
    if (!content) {
      throw new Error("No response from OpenAI API")
    }

    // Try to parse the JSON response
    let parsedResult
    try {
      // Extract JSON from the response (in case there's extra text)
      const jsonMatch = content.match(/\{[\s\S]*\}/)
      if (!jsonMatch) {
        throw new Error("No JSON found in response")
      }
      parsedResult = JSON.parse(jsonMatch[0])
    } catch (parseError) {
      console.error("Failed to parse OpenAI response:", content)
      throw new Error("Invalid response format from AI detection")
    }

    // Validate the response
    if (typeof parsedResult.ai_probability !== 'number') {
      throw new Error("Invalid AI probability score")
    }

    const aiProbability = Math.max(0, Math.min(100, Math.round(parsedResult.ai_probability)))
    const confidence = Math.max(0, Math.min(100, Math.round(parsedResult.confidence || 70)))

    return {
      ai_probability: aiProbability,
      human_probability: Math.round(100 - aiProbability),
      confidence,
      analysis: parsedResult.analysis || `AI detection analysis: ${aiProbability}% probability of AI generation.`,
      timestamp: new Date().toISOString(),
      status: 'success'
    }

  } catch (error) {
    console.error("OpenAI AI detection failed:", error)
    throw error
  }
}

// Fallback detection using basic heuristics
export function detectAIWithHeuristics(text: string): AIDetectionResult {
  const words = text.split(/\s+/).filter(Boolean)
  const sentences = text.split(/[.!?]+/).filter(Boolean)
  
  let aiScore = 0
  const analysis: string[] = []

  // Check for repetitive patterns
  const wordFrequency = new Map<string, number>()
  words.forEach(word => {
    const cleanWord = word.toLowerCase().replace(/[^\w]/g, '')
    if (cleanWord.length > 3) {
      wordFrequency.set(cleanWord, (wordFrequency.get(cleanWord) || 0) + 1)
    }
  })

  const repetitiveWords = Array.from(wordFrequency.entries())
    .filter(([_, count]) => count > 3)
    .length

  if (repetitiveWords > 5) {
    aiScore += 20
    analysis.push("High word repetition detected")
  }

  // Check for formal language patterns
  const formalPatterns = [
    "furthermore", "moreover", "in addition", "consequently", "therefore",
    "thus", "hence", "as a result", "in conclusion", "it is important to note",
    "it is worth noting", "it can be argued", "this demonstrates", "this indicates"
  ]

  const formalCount = formalPatterns.filter(pattern => 
    text.toLowerCase().includes(pattern)
  ).length

  if (formalCount > 3) {
    aiScore += 15
    analysis.push("Excessive formal language patterns")
  }

  // Check sentence length variation
  const sentenceLengths = sentences.map(s => s.split(/\s+/).length)
  const avgLength = sentenceLengths.reduce((a, b) => a + b, 0) / sentenceLengths.length
  const lengthVariation = Math.max(...sentenceLengths) - Math.min(...sentenceLengths)

  if (lengthVariation < 5) {
    aiScore += 15
    analysis.push("Low sentence length variation")
  }

  if (avgLength > 25) {
    aiScore += 10
    analysis.push("Very long average sentence length")
  }

  // Check for contractions (lack of contractions suggests AI)
  const contractions = ["don't", "can't", "won't", "it's", "that's", "there's", "they're", "you're"]
  const hasContractions = contractions.some(c => text.toLowerCase().includes(c))
  
  if (!hasContractions && text.length > 200) {
    aiScore += 10
    analysis.push("No contractions found (suggests formal/AI writing)")
  }

  // Normalize score
  const finalScore = Math.min(Math.max(Math.round(aiScore), 0), 100)
  const confidence = Math.min(70, Math.abs(50 - finalScore) * 2)

  return {
    ai_probability: finalScore,
    human_probability: Math.round(100 - finalScore),
    confidence,
    analysis: analysis.length > 0 ? analysis.join(". ") : "Text appears to be naturally written.",
    timestamp: new Date().toISOString(),
    status: 'success'
  }
} 